# 2025-12-10 JavaScript授業ノート（スクロール表示＆AJAX）

## 授業概要

- 教科書 Chapter 7 のスクロール連動アニメーション（IntersectionObserver＋Web Animations API）を実装し、要素が一度だけふわっと表示されるようにした。[^1][^2]
- Chapter 8 でエラーの考え方・コンソールの見方・よくあるミスを確認。
- Notion教材を使って、XMLHttpRequest と Fetch API による JSON 取得とHTMLへの出力を実装した。[^3][^4]

***

## スクロールで要素を表示（IntersectionObserver）

### 使った主なコード

```js
// スクロールで要素を表示
const animateFade = (entries, obs) => {
  console.log('フェードイン');
  console.log(entries);

  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      console.log(entry.target, 'が交差しました');

      entry.target.animate(
        {
          opacity: [0, 1],
          filter: ['blur(.4rem)', 'blur(0)'],
          translate: ['0 4rem', 0],
        },
        {
          duration: 2000,
          easing: 'ease',
          fill: 'forwards',
        }
      );

      // 一度アニメーションしたら監視解除
      obs.unobserve(entry.target);
    }
  });
};

const fadeObserver = new IntersectionObserver(animateFade);
const fadeElements = document.querySelectorAll('.fadein');

fadeElements.forEach((el) => {
  fadeObserver.observe(el);
});
```

```css
/* ふわっと表示させる対象の初期状態 */
.fadein {
  opacity: 0;
}
```

- `.fadein` 要素を `querySelectorAll` で取得し、`IntersectionObserver` で監視。画面に入ったときだけ `entry.target.animate()` で透明＋ぼかし＋下からのスライドを2秒かけて実行した。[^2][^5]
- `fill: 'forwards'` により、アニメーション後の状態（opacity:1 など）が維持され、CSSの `opacity: 0;` よりもアニメーションの最終値が優先される。[^6]
- コールバックの第2引数 `obs` を使い、`obs.unobserve(entry.target)` で一度表示した要素の監視を解除し、何度もアニメーションが走らないようにした。[^3]

***

## エラーと解決方法（Chapter 8）

- エラーメッセージは「動いていないことを教えてくれるありがたいメッセージ」として受け止める。まずはコンソールで「どのファイルの何行目で、どんな種類のエラーか」を確認することが重要だと学んだ。[^7]
- `ReferenceError: ○○ is not defined`（変数・関数名のミス）、`SyntaxError: Unexpected token`（カンマやカッコの抜け）、`ERR_FILE_NOT_FOUND`（パス間違い）など、よくあるパターンをチェックリスト形式で整理していた。[^4][^8]
- サンプルコードと diff ツールで差分を探す・AI に質問してヒントを得るなど、「どこが違うか」を客観的に見る方法も紹介されていた。

***

## JSON と AJAX（XMLHttpRequest版）

### メインコード

```js
const btn = document.querySelector('#btn');
const info = document.querySelector('#car-info');

// XMLHttpRequestインスタンスを1つ作成
const request = new XMLHttpRequest();

// クリック回数（cars1.json → cars2.json → cars3.json）
let counter = 1;

btn.addEventListener('click', () => {
  // 取得するJSONファイルを指定してGETリクエストを準備
  request.open(
    'GET',
    `https://norixx.github.io/jquery_elearing/cars${counter}.json`
  );

  // 通信完了時の処理
  request.onload = () => {
    if (request.status == 200) {
      // JSON文字列 → JSオブジェクト（配列）に変換
      const data = JSON.parse(request.responseText);
      console.log(data);
      outputHtml(data);
    } else {
      alert('サーバへの接続はできましたが、データが取得できませんでした');
    }
  };

  // 通信エラー時の処理
  request.onerror = () => {
    alert('接続エラー');
  };

  // リクエスト送信
  request.send();

  // 次に読み込むファイル番号を進める
  counter++;
  if (counter > 3) {
    // 3回読み込んだらボタンを無効化
    btn.setAttribute('disabled', 'disabled');
  }
});

// JSONデータをHTMLに変換して表示
function outputHtml(data) {
  let htmlStr = '';

  data.forEach((car) => {
    // colors配列を '赤,青,白' のような文字列に
    let colorStr = car.colors.join();
    htmlStr += `<p>${car.name}は${car.brand}の${car.type}タイプの車です。<br>色の展開: ${colorStr}</p>`;
  });

  // 既存の内容の末尾にまとめて追加
  info.insertAdjacentHTML('beforeend', htmlStr);
}
```

- `new XMLHttpRequest()` でインスタンスを作成し、`open → onload/onerror セット → send` という基本パターンでJSONファイルを取得する流れを確認した。[^9][^4]
- レスポンスは最初文字列なので `JSON.parse(request.responseText)` で配列に変換し、その配列を `outputHtml` に渡す。ここで `data.forEach((car) => { ... })` を使って「1台分ずつテキストを組み立てる」処理を実装した。[^8][^3]
- `let htmlStr = ''` を forEach の外で1回だけ宣言し、中で `htmlStr += ...` と追記していく必要があること、forEach の中で `let htmlStr = ''` を書くと毎回リセットされてしまうことも理解できた。

***

## Fetch API と async/await（おまけ）

### サンプルコード

```js
// Fetch APIを使った非同期通信（おまけ）
async function fetchCars() {
  try {
    // cars1.json を Fetch API で取得
    const result = await fetch(
      'https://norixx.github.io/jquery_elearing/cars1.json'
    );
    console.log(result);

    // ステータスコード200のときだけJSONとして読み込む
    if (result.status === 200) {
      const carsData = await result.json(); // JSON → JSオブジェクト
      console.log(carsData);
    } else {
      alert('サーバ接続はできましたが、ファイルの取得ができませんでした。');
    }
  } catch (error) {
    // ネットワークエラーなど
    console.log(error);
  }

  console.log('エラーが発生しています');
}

// ページ読み込み時に1回だけFetchのサンプルを実行
fetchCars();
```

- `fetch(url)` が `Promise<Response>` を返すこと、`await fetch(...)` と `await result.json()` を使うと「XMLHttpRequest + JSON.parse」とほぼ同じ処理をよりシンプルに書けることを確認した。[^10][^11]
- クリック時にも使う場合は `btn.addEventListener('click', async () => { ... })` としてイベントコールバック自体を `async` にし、その中で `await fetch(...)` ＋ `await result.json()` を呼べばよいことも学んだ。[^12][^13]

***

## 今日の気づき・今後の課題

- IntersectionObserver の `entries`・`entry.target`・`isIntersecting` の関係が少しずつイメージできてきたが、複数要素を扱うときに混乱しやすいので、簡単なデモを自作して復習したい。[^14]
- `forEach` で配列を処理するとき、「外で箱を作って中で `+=` する」パターン（今回の `htmlStr`）を何度か練習して、`for` 文との頭の切り替えに慣れていきたい。[^15]
- XMLHttpRequest と Fetch API の書き方の違い（イベントハンドラ vs async/await）を意識して、どちらでも同じ処理を書けるようにすると理解が深まりそうだと感じた。[^16][^17]

<div align="center">⁂</div>

[^1]: https://zenn.dev/ruka_311/articles/01604e6be174cd

[^2]: https://blog.hacoworks.jp/fadein/

[^3]: https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver

[^4]: https://ja.javascript.info/xmlhttprequest

[^5]: https://developer.mozilla.org/ja/docs/Web/API/IntersectionObserver

[^6]: https://developer.mozilla.org/ja/docs/Web/API/Element/animate

[^7]: https://web.dev/articles/intersectionobserver

[^8]: https://magazine.techacademy.jp/magazine/27722

[^9]: https://gray-code.com/javascript/load-file-with-xml-http-request/

[^10]: https://developer.mozilla.org/ja/docs/Web/API/Fetch_API/Using_Fetch

[^11]: https://developer.mozilla.org/ja/docs/Web/API/Fetch_API

[^12]: https://www.rstone-jp.com/column/143853/

[^13]: https://ja.javascript.info/async-await

[^14]: https://sellp.co.jp/2025/03/js_intersection_observer/

[^15]: https://techis.jp/guide/js/js_arrays

[^16]: https://kinsta.com/jp/blog/javascript-http-request/

[^17]: https://qiita.com/uhyo/items/91649e260165b35fecd7

