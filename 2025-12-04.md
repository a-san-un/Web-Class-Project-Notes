# 2025-12-04 JavaScript授業ノート
***

## 授業情報

- 日付: 2025-12-04
- 教科書: 「1冊ですべて身につくJavaScript入門講座」Chapter 6-16, 7-1〜7-3
- 範囲:
    - 6-16 スクロールとアニメーションを組み合わせよう
    - 7-1 作成するWebページの紹介
    - 7-2 ローディングから画面遷移（完成イメージ理解）
    - 7-3 画面遷移のスクリーンを作ろう（グレー＋薄緑スクリーン途中まで）
    - 課題範囲変更に伴う Chapter 5 の配列メソッド復習（forEach / map / filter / some）

***

## 学んだこと 1: スクロール連動アニメーション（Chapter 6-16）

- `IntersectionObserver` を使って、キリン画像がビューポート内に入ったタイミングで `animate()` を呼び出すスクロール連動アニメーションを実装した。
- `entries[^0].isIntersecting` が `true` になるのは、監視対象が `root`（今回は画面）と交差し始めた瞬間であり、そこでアニメーションを開始することで「スクロールでふわっと出てくる」表現ができると理解した。
- `isAnimated` フラグと `if (isAnimated || !entries[^0].isIntersecting) return;` により、「まだ一度も実行しておらず、かつ画面内に入ったときだけ動く」という条件分岐パターンを練習した。


### キリン画像のコード例

```javascript
let isAnimated = false;

const showkirin = (entries) => {
  if (isAnimated || !entries[^0].isIntersecting) return;

  const keyframes = {
    opacity: [0, 1],
    translate: ['200px 0', '0'],
  };

  entries[0].target.animate(keyframes, 600);
  isAnimated = true;
};

const kirinObserver = new IntersectionObserver(showkirin);
kirinObserver.observe(document.querySelector('#kirin'));
```


***

## 学んだこと 2: 交差判定オプション（root / rootMargin / threshold）

- `root` は「どの領域との交差を監視するか」を決めるオプションで、`null` の場合はビューポート全体、それ以外では指定したスクロールコンテナ内での交差を判定する。
- `rootMargin` は交差判定領域を上下左右に拡大・縮小するもので、`'100px'` なら画面より100px手前で発火、`'0px 0px -20% 0px'` なら画面下20%を除外して中央付近で発火するなど、早め／遅めの検知に使える。
- `threshold` は要素の「見え具合」を 0〜1 で指定し、`0` は1pxでも見えたら、`0.5` は半分見えたら、`1` は全て見えたら `isIntersecting` を true にする設定であり、配列で `[0, 0.5, 1]` のように複数段階のタイミングを扱うこともできる。

***

## 学んだこと 3: CSSアニメーションと Web Animations API の違い

- CSSアニメーションは `@keyframes` と `animation` プロパティでスタイルシートに宣言し、ホバーや単純な状態切り替えなどの「決まった動き」を記述するのに向いている。
- Web Animations API（`element.animate()`）はJavaScript側にキーフレームとオプションを記述し、`if` 文や変数・状態フラグと組み合わせて「条件に応じたアニメーション」や「一度だけ実行」などの細かい制御がしやすい。
- CSSでは途中停止や巻き戻しなどがやや扱いづらいのに対し、Web Animations API は戻り値の `Animation` オブジェクト経由で `play()`, `pause()`, `reverse()` などのメソッドを使って再生制御が可能であり、Chapter 6-16・7のようなインタラクティブな動きに適している。

***

## 学んだこと 4: ローディング画面と画面遷移（Chapter 7-1〜7-3）

- ファッションブランドサイト「WCB Fashion Collection」の完成イメージとディレクトリ構成（`Fashion/index.html`, `js/script.js`, `css/style.css`, `images/...`）を確認し、今後作り込む全体像を把握した。

```
- `<body>` 冒頭に `<div id="loading">` と `<div id="loading-screen">` を追加し、`position: fixed; inset: 0; z-index` の組み合わせでグレーのローディングレイヤーと薄緑スクリーンの2重レイヤーを構成した。
```

- `.hero .title` に `position: absolute; top: 50%; left: 50%; translate: -50% -50%;` を適用し、ヒーローセクション中央にタイトルテキストを配置するレイアウトテクニックを使った。


### ローディングと薄緑スクリーンのコード例

```javascript
const loadingAreaGrey = document.querySelector('#loading');
const loadingAreaGreen = document.querySelector('#loading-screen');

window.addEventListener('load', () => {
  loadingAreaGrey.animate(
    [
      { opacity: 1 },
      { opacity: 0, visibility: 'hidden' }
    ],
    {
      duration: 2000,
      delay: 1200,
      easing: 'ease',
      fill: 'forwards'
    }
  );

  loadingAreaGreen.animate(
    {
      translate: ['0 100vh', '0 0', '0 -100vh']
    },
    {
      duration: 2000,
      delay: 800,
      easing: 'ease',
      fill: 'forwards'
    }
  );
});
```

- 読み込み完了後、薄緑スクリーンが下から中央を通って上へ抜け、その少し後にグレーのローディング画面が2秒かけてフェードアウトする流れまで実装した。

***

## 学んだこと 5: 課題対策の配列メソッド復習（Chapter 5 相当）

- 来週提出の課題範囲が Chapter 5 までに変更され、array フォルダで配列メソッド `forEach`, `map`, `filter`, `some` の復習を行った。
- 電車路線名の配列 `trains` を題材に、それぞれが「副作用のみ」「変換」「抽出」「条件判定」という役割を持つことを整理した。


### 配列のコード例

```javascript
const trains = ['JR山手線', '東急田園都市線', '都営浅草線'];

// forEach: 各要素に処理を行うが新しい配列は作らない
trains.forEach((train, index) => {
  console.log(`${index + 1} ${train}`);
});

// 通常の for 文との比較
for (let i = 0; i < trains.length; i++) {
  console.log(`${i + 1}番目の電車は${trains[i]}です`);
}

// map: 各要素を変換して新しい配列を返す
const trainsWithNumber = trains.map((train, index) => {
  return `${index + 1} ${train}`;
});
console.log(trainsWithNumber);

// filter: 条件を満たす要素だけを集めた新しい配列を返す
const trainsFiltered = trains.filter(train => train.includes('JR'));
console.log(trainsFiltered);

// some: 条件に合う要素が1つでもあれば true を返す
const hasKeio = trains.some((train) => {
  return train.includes('京王');
});
console.log(hasKeio);
```

- `forEach` は「1件ずつ処理するだけ」であり、結果をためたいときは自分で配列を用意する必要があると確認した。
- `map` と `filter` は元の配列を変更せずに新しい配列を返すため、関数型スタイルのコードや課題でよく使われるパターンだと理解した。
- `some` は真偽値を返すメソッドで、「この条件を満たす要素が存在するか？」だけ知りたいケース（例: `'京王'` を含む路線があるか）に向いている。

***

## 疑問点・メモ

- `IntersectionObserverEntry.isIntersecting` が true になる正確な位置感覚（`threshold` や `rootMargin` を変えたときの挙動）がまだ完全にはイメージできていないため、今後は設定を変えながらコンソールログで確認したい。
- 配列メソッドは名前と戻り値が似ていて混乱しやすいので、
    - `forEach`: 処理だけ
    - `map`: 変換して配列
    - `filter`: 絞り込んで配列
    - `some`: 条件を満たす要素の有無（真偽値）
という役割を意識して覚えておくことが課題対策にも重要だと感じた。

